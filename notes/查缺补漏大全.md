# HTML

# CSS

## 动画

两大组成部分：transition和animation

#### transition

过渡、css3引入transition后有了时间轴的概念

```css
transition: 1s height, 1s width;
// 延迟1秒
transition: 1s height, 1s 1s width;
// 变速播放
transition: 1s ease;
```

**说明**

transition需要明确知道，开始状态和结束状态的具体数值，才能计算出中间状态。比如，height从0px变化到100px，transition可以算出中间状态。但是，transition没法算出0px到auto的中间状态，也就是说，如果开始或结束的设置是height: auto，那么就不会产生动画效果。类似的情况还有，display: none到block，background: url(foo.jpg)到url(bar.jpg)等等

**局限**

1. transition需要事件触发，所以没法在网页加载时自动发生。
2. transition是一次性的，不能重复发生，除非一再触发。
3. transition只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。
4. 一条transition规则，只能定义一个属性的变化，不能涉及多个属性。

#### Animation

CSS Animation需要指定动画一个周期持续的时间，以及动画效果的名称。

```css
animation: 1s rainbow;
@keyframes rainbow {
  0% { background: #c00; }
  50% { background: orange; }
  100% { background: yellowgreen; }
}

```

加入infinite关键字，可以让动画无限次播放。也可以指定动画具体播放的次数，比如3次。

动画结束以后，会立即从结束状态跳回到起始状态。如果想让动画保持在结束状态，需要使用animation-fill-mode属性。

## 盒模型

box-sizing: content-box和border-box

标准content-box 实际宽度 = width + border + padding

怪异border-box  实际宽度 = width

## 图片固定宽高

图片是单独加载的，固定宽高只需要预留位置，而不固定需要来回调整，因此固定宽高可以消除不必要的回流

# JS

## 遍历对象

1. for in(包含原型) 属性名
2. Object.keys(不包含原型) 返回属性名数组
3. Object.values(不包含原型) 返回属性值数组
4. Object.entries (不包含原型) 返回属性名和属性值的数组（每一项为[key,value]）
5. Object.getOwnPropertyNames(不包含原型) 返回属性名数组

## 判断数组方法

1. obj instanceof Array
2. Array.prototype.isPrototypeOf(obj)
3. Object.prototype.toString.call(obj)
4. Array.isArray(obj)
5. obj.constructor.name

# VUE

## 组件间通信

props、events、

## 监听数组变化

## 双向数据绑定

## defineProperty和Proxy

## vue2和vue3的区别

# React

## useReducer和useCallback

# 浏览器

### 渲染界面过程

https://www.jianshu.com/p/a5f26487f097

1. 解析html，构建dom树

2. 解析css，构建cssom树

3. 合并dom和cssom，生成render树

    这里有一个细节，不是所有的dom节点都会生成render节点，例如cssom上是display:none

4. **Layout/reflow** 布局render树，计算各个元素的尺寸和位置

5. **paint** 绘制render树，绘制页面的像素信息

### 重绘和重排

**重绘**

外观发生改变

常见：color、visibility、opacity、background-image

**重排**

布局发生改变

常见触发属性：width、margin、padding、display

**注意**

transfrom不会触发重绘和重排，动画由GPU控制，支持硬件加速

### 浏览器缓存

主要字段：Expires、Pragma、Cache-Control、Last-Modified/If-None-Match、Etag/If-Modified-Since

**强缓存**

200 Pragma>Cache-Control>Expires

Cache-Control:no-cache、no-store、max-age

**协商缓存**

第一次服务器给到Last-Modified、Etag 

之后客户端拿着If-Modified-Since、If-None-Match

> 如果我们的服务端在一秒内修改了文件，那么Last-Modified是验证不到的

这个时候`Etag`的值就显得尤为重要，所以如果我们的系统同时用到这两组字段来验证缓存，那就意味着必须这两项都通过才能返回`304`。

### 为什么js放在最下面

### css放在最下面有什么影响

### 浏览器内核

### GUI渲染线程和JS引擎线程是互斥的

# 网络

### 网络请求过程

1. dns域名解析

    查找域名对应ip的过程，会逐级的从缓存中查找：

    - 浏览器缓存
    - 操作系统缓存
    - 路由(器)缓存
    - ISP的DNS服务器
    - 根服务器

    使用udp协议传输

2. 建立TCP连接

    三次握手如下：

    1. 客户端->服务端

        SYN=1 seq=x

    2. 服务端->客户端

        SYN=1 ACK=1 seq=y ack=x+1

    3. 客户端->服务端

        ACK=1 seq=x+1 ack=y+1

    四次挥手如下：

    1. 客户端->服务端

        FIN=1 seq=x

    2. 服务端->客户端

        ACK=1 ack=x+1 seq=y

    3. 服务端->客户端

        FIN=1 ACK=1 ack=x+1 seq=z

    4. 客户端->服务端

        ACK=1 ack=z+1 seq=x+1

    **2msl等待原因**

    如果最后一次的报文段没有传输到服务端，服务端会超时重传，当我在2msl内再次受到服务端传来的第三个报文段，那就说明我的报文段没有传输成功，我需要重传第四个报文段并重新开始2msl的等待

3. 浏览器发送http请求

4. 服务器处理http请求，返回请求资源

5. 浏览器解析并渲染界面

    渲染步骤见浏览器部分

### HTTPS

步骤如下：

1. 客户端->服务器

    hello、TLS版本、加密套件、随机数1

2. 服务器->客户端

    hello、TLS版本、加密套件、随机数2

3. 服务器->客户端

    CA证书

4. 服务器->客户端

    公钥

5. 服务器->客户端

    告诉客户端结束

6. 客户端->服务器

    发送拿公钥的第三个随机数

双方将3个随机数混合等到相同的密钥，进行对称加密

### XSS和CSRF

#### xss

xss核心做法：合法操作：url输入、评论框输入、script

盗用Cookie

破坏页面的正常结构，插入广告等恶意内容

D-doss攻击

**预防措施**

1. 在cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息，这样能有效的防止XSS攻击
2. 移除用户输入的和事件相关的属性。如onerror可以自动触发攻击，还有onclick等。（总而言是，过滤掉一些不安全的内容）
3. 移除用户输入的Style节点、Script节点、Iframe节点。（尤其是Script节点，它可是支持跨域的呀，一定要移除）。

#### csrf

用户登录A网站产生cookie，此时再访问B（危险），B要求访问A，并发起一个请求

此时，B（危险）就利用用户的权限在A进行了操作。

**预防措施**

token验证或者在请求头上带上x-csrf-token

#### CSRF 和 XSS 的区别

区别一：

​	CSRF：需要用户先登录网站A，获取 cookie。
 	XSS：不需要登录。

区别二：（原理的区别）

​	CSRF：是利用网站A本身的漏洞，去请求网站A的api。
 	XSS：是向网站 A 注入 JS代码，然后执行 JS 里的代码，篡改网站A的内容。

# 算法

## 最长公共子序列

## 最长公共字串